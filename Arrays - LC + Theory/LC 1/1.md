# LeetCode 1: Two Sum

## Problem Statement
Given an array of integers `nums` and an integer `target`, return **indices** of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may **not use the same element twice**.

You can return the answer in any order.

---

## Prerequisites & Concepts

### 1. **Array Fundamentals**
- Understanding array indexing (0-based)
- Accessing elements by index
- Iterating through arrays

### 2. **Hash Tables / Hash Maps**
- Key-value pair storage
- O(1) average lookup time
- In C++: `unordered_map<int, int>`
- Understanding hash collisions

### 3. **Complement Concept**
- If `a + b = target`, then `b = target - a`
- For each number, we look for its "complement"
- Example: target = 9, current = 2, complement = 7

### 4. **Time-Space Tradeoff**
- Trading space for time efficiency
- Using additional memory to reduce time complexity

---

## Approaches to Solve

### Approach 1: Brute Force
**Idea**: Check every possible pair of numbers to see if they sum to target.

**Algorithm**:
1. Use two nested loops
2. Outer loop: iterate through each element (i)
3. Inner loop: check all elements after i (j = i+1)
4. If `nums[i] + nums[j] == target`, return `[i, j]`

**Time Complexity**: O(n²)
**Space Complexity**: O(1)

**Why it's inefficient**:
- Checks many unnecessary pairs
- For n elements, checks n(n-1)/2 pairs
- Doesn't leverage any additional data structure

**Code Structure**:
```cpp
for(int i = 0; i < n - 1; i++) {
    for(int j = i + 1; j < n; j++) {
        if(nums[i] + nums[j] == target) {
            return {i, j};
        }
    }
}
```

---

### Approach 2: Hash Map (Optimal)
**Idea**: Use a hash map to store numbers we've seen and their indices. For each number, check if its complement exists in the map.

**Core Insight**:
- Instead of checking all pairs, look up the complement in O(1) time
- Store numbers as we go, so we can find complements of future numbers
- One pass through the array is sufficient

**Algorithm**:
1. Create an empty hash map: `unordered_map<int, int>` (value → index)
2. For each element at index `i`:
   - Calculate complement: `target - nums[i]`
   - Check if complement exists in map
   - If yes: return `[map[complement], i]`
   - If no: add current number to map: `map[nums[i]] = i`
3. Return empty vector if no solution (won't happen per problem constraints)

**Time Complexity**: O(n) - Single pass through array
**Space Complexity**: O(n) - Hash map can store up to n elements

**Why it's optimal**:
- Only one pass through the array
- Constant time lookup for complement
- Trades space for significant time improvement

---

### Approach 3: Two Pointers (Greedy)
**Idea**: Sort the array while preserving indices, then use two pointers (left and right) moving towards each other based on the sum.

**Core Insight**:
- In a sorted array, we can use greedy approach with two pointers
- If sum is too small, move left pointer right (increases sum)
- If sum is too large, move right pointer left (decreases sum)
- Challenge: We need to return original indices, so we must track them during sorting

**Algorithm**:
1. Create pairs of `(value, original_index)` for all elements
2. Sort the pairs by value
3. Initialize `left = 0`, `right = n-1`
4. While `left < right`:
   - Calculate `sum = arr[left] + arr[right]`
   - If `sum == target`: return the original indices
   - If `sum < target`: increment `left` (need larger sum)
   - If `sum > target`: decrement `right` (need smaller sum)
5. Return empty if no solution

**Time Complexity**: O(n log n) - Dominated by sorting
**Space Complexity**: O(n) - For storing pairs

**When to use**:
- When array is already sorted (no need for pairs, O(1) space)
- Educational purposes to learn the two-pointer pattern
- LeetCode 167 (Two Sum II - Input Array Is Sorted)

**Why it's not optimal for this problem**:
- Hash map is O(n) vs O(n log n) for sorting
- Need extra space anyway to track indices
- Only preferred when array is pre-sorted

**Code Structure**:
```cpp
// Create pairs of (value, index)
vector<pair<int, int>> numWithIndex;
for(int i = 0; i < nums.size(); i++) {
    numWithIndex.push_back({nums[i], i});
}

// Sort by value
sort(numWithIndex.begin(), numWithIndex.end());

// Two pointers
int left = 0, right = n - 1;
while(left < right) {
    int sum = numWithIndex[left].first + numWithIndex[right].first;
    if(sum == target) return {numWithIndex[left].second, numWithIndex[right].second};
    else if(sum < target) left++;
    else right--;
}
```

---

## Two Pointers Approach - Detailed Walkthrough

### Example: `nums = [2, 7, 11, 15]`, `target = 9`

**Step 1: Create pairs and sort**
```
Original: [(2,0), (7,1), (11,2), (15,3)]
After sort: [(2,0), (7,1), (11,2), (15,3)] // Already sorted in this case
```

**Step 2: Two pointers traversal**

| Step | left | right | nums[left] | nums[right] | Sum | Comparison | Action |
|------|------|-------|------------|-------------|-----|------------|--------|
| 1 | 0 | 3 | 2 | 15 | 17 | 17 > 9 | right-- |
| 2 | 0 | 2 | 2 | 11 | 13 | 13 > 9 | right-- |
| 3 | 0 | 1 | 2 | 7 | 9 | 9 == 9 | **Found!** |

**Return**: `[0, 1]` (original indices)

### Example 2: `nums = [3, 2, 4]`, `target = 6`

**Step 1: Create pairs and sort**
```
Original: [(3,0), (2,1), (4,2)]
After sort: [(2,1), (3,0), (4,2)]
```

**Step 2: Two pointers traversal**

| Step | left | right | Value[left] | Value[right] | Sum | Comparison | Action |
|------|------|-------|-------------|--------------|-----|------------|--------|
| 1 | 0 | 2 | 2 | 4 | 6 | 6 == 6 | **Found!** |

**Return**: `[1, 2]` (original indices from the pairs)

---

## Comparing All Three Approaches

| Approach | Time | Space | Best For | Modifies Array? |
|----------|------|-------|----------|-----------------|
| Brute Force | O(n²) | O(1) | Very small arrays, no extra space | No |
| Hash Map | O(n) | O(n) | **Unsorted arrays** (optimal) | No |
| Two Pointers | O(n log n) | O(n)* | **Already sorted arrays** | Yes (sorts) |

*O(1) space if array is already sorted and we can use value pairs or don't need exact original indices

### Which to choose?
- **Unsorted array** → Hash Map (O(n) is better than O(n log n))
- **Already sorted** → Two Pointers (O(n) time, O(1) space)
- **Interview** → Start with brute force, optimize to hash map, mention two pointers as alternative

---

## Hash Map Approach - Detailed Walkthrough

### Example 1: `nums = [2, 7, 11, 15]`, `target = 9`

| Iteration | i | nums[i] | Complement (9 - nums[i]) | Map Before | Found? | Action | Result |
|-----------|---|---------|--------------------------|------------|--------|--------|--------|
| 1 | 0 | 2 | 7 | {} | No | Add 2→0 | - |
| 2 | 1 | 7 | 2 | {2→0} | **Yes!** | Found at index 0 | **[0, 1]** |

**Explanation**:
- Iteration 1: Looking for 7, not in map yet, store 2
- Iteration 2: Looking for 2, found it at index 0! Return [0, 1]

### Example 2: `nums = [3, 2, 4]`, `target = 6`

| Iteration | i | nums[i] | Complement | Map Before | Found? | Action |
|-----------|---|---------|------------|------------|--------|--------|
| 1 | 0 | 3 | 3 | {} | No | Add 3→0 |
| 2 | 1 | 2 | 4 | {3→0} | No | Add 2→1 |
| 3 | 2 | 4 | 2 | {3→0, 2→1} | **Yes!** | **[1, 2]** |

**Note**: We find 4's complement (2) at index 1

### Example 3: `nums = [3, 3]`, `target = 6`

| Iteration | i | nums[i] | Complement | Map Before | Found? | Action |
|-----------|---|---------|------------|------------|--------|--------|
| 1 | 0 | 3 | 3 | {} | No | Add 3→0 |
| 2 | 1 | 3 | 3 | {3→0} | **Yes!** | **[0, 1]** |

**Key Point**: Same values can be used if they're at different indices

---

## Why Hash Map Works

### The Magic of Complement Lookup

**Traditional Approach (Brute Force)**:
- For each element, check ALL other elements
- "Does this + that = target?"
- Requires nested loops

**Hash Map Approach**:
- For each element, ask: "What number would I need to reach target?"
- "Is that number something I've already seen?"
- Uses precomputed storage for instant lookup

**Mathematical Proof**:
```
If nums[i] + nums[j] = target
Then nums[j] = target - nums[i]

When we're at position i:
- We calculate: complement = target - nums[i]
- We check: Have we seen this complement before?
- If yes: We found our pair!
```

---

## Step-by-Step Thinking Process

### When you see this problem, ask yourself:

1. **What information do I need for each number?**
   - Its value
   - Its index (to return in result)

2. **What am I searching for at each step?**
   - The complement that would sum to target

3. **How can I make searching fast?**
   - Store previous numbers in a hash map
   - Hash map gives O(1) lookup

4. **What do I store in the map?**
   - Key: the number's value
   - Value: the number's index
   - Format: `unordered_map<int, int>`

5. **When do I add to the map?**
   - After checking if complement exists
   - This prevents using the same element twice

---

## Edge Cases to Consider

### 1. **Duplicate Values**: `[3, 3]`, target = 6
```
✅ Valid: Different indices can have same value
Answer: [0, 1]
Important: Don't add to map before checking!
```

### 2. **Same Index Twice**: `[5]`, target = 10
```
❌ Invalid: Can't use same element twice
This won't happen (problem guarantees exactly one solution)
```

### 3. **Negative Numbers**: `[-1, -2, -3, -4, -5]`, target = -8
```
✅ Algorithm works the same way
Complement: -8 - (-3) = -5
Answer: [2, 4]
```

### 4. **Zero Values**: `[0, 4, 3, 0]`, target = 0
```
✅ Valid pairing of two zeros
Answer: [0, 3]
```

### 5. **Large Numbers**: `[1000000000, 2, 1000000000]`, target = 2000000000
```
✅ Be careful of integer overflow
Use appropriate data types
Answer: [0, 2]
```

### 6. **No Solution**: 
```
According to problem: "exactly one solution exists"
Still good practice to return empty vector if no solution
```

---

## Implementation Details for C++

### 1. **Choosing the Right Map**

```cpp
// Use unordered_map for O(1) average lookup
unordered_map<int, int> map; // ✅ Optimal

// Don't use regular map (O(log n) lookup)
map<int, int> map; // ❌ Slower
```

### 2. **Order of Operations** (CRITICAL!)

```cpp
// ✅ CORRECT: Check first, then add
int complement = target - nums[i];
if(map.find(complement) != map.end()) {
    return {map[complement], i};
}
map[nums[i]] = i;

// ❌ WRONG: Adding first causes issues with duplicates
map[nums[i]] = i;
if(map.find(complement) != map.end()) {
    return {map[complement], i}; // Might return same index!
}
```

**Why?** If you add first, checking for the same value will find itself!

### 3. **Checking Map Existence**

```cpp
// Method 1: Using find()
if(map.find(complement) != map.end()) { ... }

// Method 2: Using count()
if(map.count(complement)) { ... }

// ❌ Don't use bracket operator for checking
if(map[complement]) { // This creates the key if it doesn't exist!
```

### 4. **Return Format**

```cpp
return {map[complement], i};        // ✅ Clean initialization
return vector<int>{index1, index2}; // ✅ Explicit type
vector<int> result = {i, j};        // ✅ With variable
return result;
```

### 5. **Two Pointer Implementation Tips**

```cpp
// ✅ CORRECT: Track original indices with pairs
vector<pair<int, int>> numWithIndex;
for(int i = 0; i < nums.size(); i++) {
    numWithIndex.push_back({nums[i], i});
}
sort(numWithIndex.begin(), numWithIndex.end());

// Access value: numWithIndex[i].first
// Access original index: numWithIndex[i].second

// ✅ Return indices in sorted order
int idx1 = numWithIndex[left].second;
int idx2 = numWithIndex[right].second;
return {min(idx1, idx2), max(idx1, idx2)};

// Alternative: Use custom struct for clarity
struct NumIndex {
    int value;
    int index;
};
```

**Greedy Strategy**:
- If current sum < target: Need larger values → move left pointer right
- If current sum > target: Need smaller values → move right pointer left  
- This works because array is sorted!

---

## Common Mistakes to Avoid

### ❌ **Mistake 1: Not returning indices**
```cpp
// Wrong: returning values instead of indices
return {nums[i], nums[j]};

// Correct: returning indices
return {i, j};
```

### ❌ **Mistake 2: Using same element twice**
```cpp
// Wrong: inner loop starts from i (includes same element)
for(int j = i; j < n; j++)

// Correct: inner loop starts from i+1
for(int j = i + 1; j < n; j++)
```

### ❌ **Mistake 3: Adding to map before checking**
```cpp
// Can cause returning same index twice
map[nums[i]] = i;
if(map.find(complement) != map.end()) ...
```

### ❌ **Mistake 4: Not handling order**
```cpp
// Problem says "any order is fine"
// Both [0, 1] and [1, 0] are acceptable
// But be consistent - usually return smaller index first
```

### ❌ **Mistake 5: Two-Pointer - Forgetting to track original indices**
```cpp
// Wrong: Sorting nums directly loses original indices
sort(nums.begin(), nums.end());
// Now you can't return the original indices!

// Correct: Sort pairs of (value, index)
vector<pair<int, int>> numWithIndex;
for(int i = 0; i < nums.size(); i++) {
    numWithIndex.push_back({nums[i], i});
}
sort(numWithIndex.begin(), numWithIndex.end());
```

### ❌ **Mistake 6: Two-Pointer - Wrong pointer movement**
```cpp
// Wrong: Moving wrong pointer
if(sum < target) right--;  // Should increase sum, not decrease!

// Correct:
if(sum < target) left++;   // Increase sum
else if(sum > target) right--;  // Decrease sum
```

---

## Complexity Analysis

### Brute Force
- **Time Complexity**: **O(n²)**
  - Outer loop: n iterations
  - Inner loop: (n-1) + (n-2) + ... + 1 = n(n-1)/2
  - Total: O(n²)
  
- **Space Complexity**: **O(1)**
  - Only using a few variables
  - No additional data structures

### Hash Map (Optimal for Unsorted)
- **Time Complexity**: **O(n)**
  - Single pass through array: O(n)
  - Hash map operations (insert/lookup): O(1) average
  - Total: O(n)
  
- **Space Complexity**: **O(n)**
  - Hash map can store up to n elements in worst case
  - Example: no solution found until last element

### Two Pointers (Greedy)
- **Time Complexity**: **O(n log n)**
  - Creating pairs: O(n)
  - Sorting pairs: O(n log n)
  - Two pointer traversal: O(n)
  - Total: O(n log n) - dominated by sorting
  
- **Space Complexity**: **O(n)**
  - Storing pairs: O(n)
  - Sorting may use O(log n) to O(n) stack space
  - Note: If array is already sorted, can achieve O(1) space

**Is the extra space worth it?**
- For n = 1000: Brute force = ~500,000 operations vs Hash map = ~1,000 vs Two Pointers = ~10,000
- For n = 1,000,000: Brute force = ~500 billion vs Hash map = ~1 million vs Two Pointers = ~20 million
- **Hash Map wins!** Best time complexity for unsorted arrays
- **Two Pointers** only better when array is pre-sorted (O(n) time, O(1) space)

---

## Visual Comparison

### Brute Force Visualization
```
nums = [2, 7, 11, 15], target = 9

Comparisons:
2+7  ✓ Found!
2+11
2+15
7+11  (skipped after finding)
7+15
11+15

Total comparisons needed: 6 (in general: n(n-1)/2)
```

### Hash Map Visualization
```
nums = [2, 7, 11, 15], target = 9

Step 1: nums[0] = 2
  - Need: 7
  - Map: {}
  - Not found, add: {2→0}

Step 2: nums[1] = 7
  - Need: 2
  - Map: {2→0}
  - Found! Return [0, 1]

Total lookups: 2 (in general: ≤ n)
```

### Two Pointers Visualization
```
nums = [2, 7, 11, 15], target = 9

Step 0: Sort (already sorted in this case)
  Pairs: [(2,0), (7,1), (11,2), (15,3)]

Step 1: left=0, right=3
  2 + 15 = 17 > 9
  Move right pointer left

Step 2: left=0, right=2
  2 + 11 = 13 > 9
  Move right pointer left

Step 3: left=0, right=1
  2 + 7 = 9 == 9
  Found! Return [0, 1]

Total comparisons: 3 (in general: ≤ n after O(n log n) sort)
```

---

## When to Use Each Approach

### Use Brute Force When:
- Array is very small (n < 10)
- Memory is extremely limited
- Problem explicitly asks for no extra space
- Interviewer asks you to start with brute force

### Use Hash Map When:
- **Array is unsorted** (most common case)
- Array size is medium to large
- Need optimal time complexity: O(n)
- Memory usage is acceptable
- Production code (real-world applications)
- **This is the preferred solution for LeetCode 1**

### Use Two Pointers When:
- **Array is already sorted** (like LeetCode 167)
- Want to achieve O(1) space with sorted input
- Learning the two-pointer pattern
- Interview follow-up: "What if array was sorted?"
- Not optimal for unsorted arrays (hash map is better)

---

## Related Problems & Variations

### Similar Problems:
1. **Two Sum II** (LeetCode 167) - Array is sorted
   - Can use two-pointer approach: O(n) time, O(1) space

2. **3Sum** (LeetCode 15) - Find three numbers
   - Sort + two pointers

3. **4Sum** (LeetCode 18) - Find four numbers
   - Extension of 3Sum

4. **Two Sum IV - BST** (LeetCode 653)
   - Two sum in binary search tree

### Variations:
- **Return the values instead of indices**
- **Find all pairs that sum to target** (not just one)
- **Count number of pairs**
- **Two sum in sorted array** (two-pointer technique)
- **Two sum less than target**

---

## Interview Tips

### What Interviewer Expects:
1. ✅ Ask clarifying questions first
   - Is array sorted?
   - Can we modify the array?
   - What if no solution exists?
   - Can negative numbers appear?

2. ✅ Start with brute force
   - Show you understand the problem
   - Explain time/space complexity

3. ✅ Optimize to hash map
   - Explain the time-space tradeoff
   - Walk through an example

4. ✅ Handle edge cases
   - Mention duplicates, negatives, etc.

5. ✅ Write clean, bug-free code
   - Check order of operations
   - Test with examples

### Common Follow-up Questions:
- "What if the array is sorted?" → Two pointer approach
- "What if we need all pairs?" → Modified hash map approach
- "What if we can't use extra space?" → Depends on if we can sort

---

## Key Takeaways

1. **Complement thinking** is the core insight
   - For each number, look for what's needed to reach target

2. **Hash maps trade space for time**
   - O(n) space for O(n²) → O(n) time improvement
   - Best approach for unsorted arrays

3. **Two pointers use greedy strategy**
   - Works on sorted arrays by moving pointers based on comparison
   - If sum too small → move left (increase), if too large → move right (decrease)
   - O(n) time but requires O(n log n) sorting first (unless pre-sorted)

4. **Order of operations matters**
   - Check before adding to prevent same-index bugs

5. **Know when to use which approach**
   - Unsorted array? → Hash Map (O(n))
   - Sorted array? → Two Pointers (O(n) with O(1) space)
   - Learning? → Try all three!

6. **This is a fundamental pattern**
   - Many problems use "seen items + lookup" approach
   - Two-pointer is a pattern used in many array problems
   - Understanding these deeply helps with harder problems

7. **One of the most asked interview questions**
   - Practice until you can code all approaches perfectly
   - Be ready to explain the intuition clearly
   - Know the tradeoffs between approaches

---

## Practice Problems for Mastery

Start with these to reinforce concepts:
1. LeetCode 167 - Two Sum II (sorted array)
2. LeetCode 15 - 3Sum
3. LeetCode 560 - Subarray Sum Equals K
4. LeetCode 1 - Two Sum (this one!)

Remember: Understanding WHY hash maps work here is more important than memorizing the code!
