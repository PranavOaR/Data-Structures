# LeetCode 53: Maximum Subarray

## Problem Statement
Given an integer array `nums`, find the **subarray** with the largest sum, and return its sum.

A **subarray** is a contiguous non-empty sequence of elements within an array.

---

## Prerequisites & Concepts

### 1. **Understanding Subarrays**
- **Subarray**: A contiguous portion of an array
- For array `[1, 2, 3]`, valid subarrays are:
  - `[1]`, `[2]`, `[3]`
  - `[1, 2]`, `[2, 3]`
  - `[1, 2, 3]`
- **NOT** valid: `[1, 3]` (not contiguous)

### 2. **Array Traversal**
- Understanding how to iterate through arrays
- Single pointer vs multiple pointers
- Nested loops for exploring all possibilities

### 3. **Dynamic Programming Concepts**
- Optimal substructure
- Overlapping subproblems
- Building solutions from smaller subproblems

### 4. **Greedy Approach**
- Making locally optimal choices
- Deciding when to extend vs restart

---

## Approaches to Solve

### Approach 1: Brute Force
**Idea**: Check sum of every possible subarray and track the maximum.

**Algorithm**:
1. Use two nested loops
2. Outer loop: starting index (i)
3. Inner loop: ending index (j)
4. Calculate sum from index i to j
5. Track maximum sum

**Time Complexity**: O(nÂ²) or O(nÂ³) depending on implementation
**Space Complexity**: O(1)

**Why it's inefficient**:
- Recalculates sums repeatedly
- Doesn't use information from previous calculations

---

### Approach 2: Kadane's Algorithm (Optimal)
**Idea**: At each position, decide whether to extend the current subarray or start a new one.

**Core Insight**:
- If current sum becomes negative, it will only decrease future sums
- Better to start fresh from the next element
- Keep track of the maximum sum seen so far

**Algorithm**:
1. Initialize `currentSum = 0` and `maxSum = INT_MIN`
2. For each element in array:
   - Add element to `currentSum`
   - Update `maxSum` if `currentSum` > `maxSum`
   - If `currentSum` < 0, reset `currentSum = 0`
3. Return `maxSum`

**Time Complexity**: O(n) - Single pass through array
**Space Complexity**: O(1) - Only two variables

---

## Kadane's Algorithm - Detailed Walkthrough

### Example 1: `nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`

| Index | Element | currentSum (before) | currentSum (after) | maxSum | Decision |
|-------|---------|---------------------|-------------------|--------|----------|
| 0 | -2 | 0 | -2 | -2 | Start with -2 |
| 1 | 1 | -2 | 1 | 1 | Reset (was negative), start fresh |
| 2 | -3 | 1 | -2 | 1 | Continue (still positive before) |
| 3 | 4 | -2 | 4 | 4 | Reset (was negative), start fresh |
| 4 | -1 | 4 | 3 | 4 | Continue |
| 5 | 2 | 3 | 5 | 5 | Continue |
| 6 | 1 | 5 | 6 | 6 | Continue |
| 7 | -5 | 6 | 1 | 6 | Continue |
| 8 | 4 | 1 | 5 | 6 | Continue |

**Best subarray**: `[4, -1, 2, 1]` with sum = **6**

### Why Kadane's Algorithm Works

**Key Principle**: 
- At any position `i`, the maximum subarray ending at `i` is either:
  1. The element itself (start fresh)
  2. The element + maximum subarray ending at `i-1` (extend)

**Mathematical Formulation**:
```
maxEndingHere[i] = max(nums[i], maxEndingHere[i-1] + nums[i])
globalMax = max(globalMax, maxEndingHere[i])
```

We can optimize space by not storing the entire array, just tracking current and max sums.

---

## Step-by-Step Thinking Process

### When you see this problem, think:

1. **What are we looking for?**
   - Maximum sum of contiguous elements

2. **What makes a subarray "good"?**
   - Its sum is positive and contributes to the total

3. **When should we abandon a subarray?**
   - When continuing it would make our sum negative

4. **What's the simplest state to track?**
   - Current running sum
   - Maximum sum seen so far

---

## Edge Cases to Consider

1. **All negative numbers**: `[-5, -2, -8, -1]`
   - Answer: `-1` (the least negative number)
   - Don't reset to 0, keep the best negative value

2. **Single element**: `[5]`
   - Answer: `5`

3. **All positive numbers**: `[1, 2, 3, 4]`
   - Answer: `10` (entire array)

4. **Mix of positive and negative**: `[5, -3, 5]`
   - Answer: `7` (entire array)

5. **Empty array**: Typically not allowed by constraints

---

## Implementation Tips for C++

### Key Points:
1. **Initialize maxSum properly**
   - Use `INT_MIN` or `nums[0]`
   - DON'T use 0 (fails for all-negative arrays)

2. **Variable naming**
   - `currentSum` or `maxEndingHere`
   - `maxSum` or `globalMax`

3. **Alternative implementation**
   - Some prefer: `currentSum = max(nums[i], currentSum + nums[i])`
   - This is more intuitive for some learners

### Common Mistakes to Avoid:
- âŒ Initializing maxSum to 0
- âŒ Forgetting to handle all-negative arrays
- âŒ Not updating maxSum before resetting currentSum
- âŒ Using unsigned integers (can't handle negatives)

---

## Complexity Analysis

### Time Complexity: **O(n)**
- Single pass through the array
- Constant work per element
- WHERE n = array length

### Space Complexity: **O(1)**
- Only using two variables regardless of input size
- No additional data structures needed

---

## Variations & Follow-ups

1. **Return the actual subarray** (not just sum)
   - Track start and end indices

2. **Circular array**
   - Maximum subarray can wrap around

3. **At least K elements**
   - Subarray must have minimum length K

4. **Divide and Conquer approach**
   - O(n log n) solution using recursion

---

## Related Concepts

- **Prefix Sum**: Alternative way to think about subarrays
- **Dynamic Programming**: Kadane's is a DP algorithm
- **Greedy Algorithms**: Local optimal choices
- **Sliding Window**: Similar pattern of extending/contracting

---

## Practice Strategy

1. **First**: Implement brute force to understand the problem
2. **Then**: Learn and implement Kadane's algorithm
3. **Finally**: Try to solve without looking at notes
4. **Practice**: Similar problems on LeetCode (121, 152, 918)

---

## C++ STL & Tools You'll Use

```cpp
#include <vector>        // For vector<int>
#include <algorithm>     // For max()
#include <climits>       // For INT_MIN
#include <iostream>      // For input/output
```

### Useful Functions:
- `max(a, b)` - Returns maximum of two values
- `INT_MIN` - Smallest possible integer value
- `vector<int>` - Dynamic array in C++

---

## Visualization Example

```
Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]

Current Sum progression:
-2 â†’ 1 â†’ -2 â†’ 4 â†’ 3 â†’ 5 â†’ 6 â†’ 1 â†’ 5
      â†‘         â†‘              â†‘
    (reset)  (reset)       (continues)

Max Sum progression:
-2 â†’ 1 â†’ 1 â†’ 4 â†’ 4 â†’ 5 â†’ 6 â†’ 6 â†’ 6
                              â†‘
                          (answer)
```

---

## Summary

**The Maximum Subarray problem** teaches you:
- âœ… How to optimize from O(nÂ²) to O(n)
- âœ… When to use greedy vs dynamic programming
- âœ… How to track multiple states while iterating
- âœ… Importance of edge case handling

**Kadane's Algorithm** is a fundamental algorithm that appears in many interview questions and real-world scenarios where you need to find optimal contiguous sequences.

---

## Next Steps

1. Read through this guide completely
2. Understand the walkthrough table above
3. Implement the brute force solution in [53.cpp](53.cpp)
4. Implement Kadane's algorithm in [53.cpp](53.cpp)
5. Test with all edge cases
6. Try to explain the algorithm to someone else

Good luck! ðŸš€
